<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Missing Semester notes——Lecture 2 Tools and Scripting</title>
      <link href="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/"/>
      <url>/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/</url>
      
        <content type="html"><![CDATA[<h1 id="Lecture-2-Tools-and-Scripting"><a href="#Lecture-2-Tools-and-Scripting" class="headerlink" title="Lecture 2 Tools and Scripting"></a><strong>Lecture 2 Tools and Scripting</strong></h1><blockquote><p>课程网址：<a href="https://missing-semester-cn.github.io/2020/shell-tools/">https://missing-semester-cn.github.io/2020/shell-tools/</a></p></blockquote><p>到目前为止，我们已经学习来如何在shell中执行命令，并使用管道将命令组合使用。但是，很多情况下我们需要执行一系列的操作并使用条件或循环这样的控制流。</p><p>shell脚本是一种更加复杂度的工具。</p><p>大多数shell都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell脚本与其他脚本语言不同之处在于，shell脚本针对shell所从事的相关工作进行来优化。因此，创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是shell脚本中的原生操作，这让它比通用的脚本语言更易用。本节中，我们会专注于bash脚本，因为它最流行，应用更为广泛。</p><h2 id="内容概览"><a href="#内容概览" class="headerlink" title="内容概览"></a>内容概览</h2><p>包括关于shell的两个部分：</p><ul><li><p><strong>Shell脚本（shell scripting）的编写</strong>，比如bash（多数mac or Linux系统中默认的shell，可以通过zsh等其他shell向后兼容）</p></li><li><p><strong>Convenient shell tools</strong>(avoid doing repetitive tasks)</p></li></ul><h2 id="1-Shell-脚本"><a href="#1-Shell-脚本" class="headerlink" title="1. Shell 脚本"></a>1. Shell 脚本</h2><h3 id="1-1-基础操作"><a href="#1-1-基础操作" class="headerlink" title="1.1 基础操作"></a>1.1 基础操作</h3><p><strong>bash中变量赋值语法:</strong><code>foo=bar</code><br>        注意不要有空格，否则解释器会把 <code>=</code> 和<code>bar</code>当成两个参数，<strong>在bash中空格有分割参数的作用</strong>。</p><p><strong>bash中访问变量：</strong><code>echo $foo</code></p><p><strong>bash中字符串定义：</strong></p><p>​        double quotes: <code>“ ”</code>     转义字符串；single quotes: <code>‘’</code> 原义字符串</p><div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/image-20211002222235419.png" class=""></div><p><strong>bash支持的循环和函数操作：</strong> <code>if while for loop</code></p><p><strong>bash脚本中的一些变量：</strong></p><ul><li><code>$0</code> - 脚本名</li><li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 $1 是第一个参数，依此类推。</li><li><code>$@</code> - 所有参数</li><li><code>$#</code> - 参数个数</li><li><code>$?</code> - 前一个命令的返回值</li><li><code>$$</code> - 当前脚本的进程识别码</li><li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 sudo !!再尝试一次。</li><li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式shell，你可以通过按下 Esc 之后键入 . 来获取这个值。</li></ul><h3 id="1-2-Vim"><a href="#1-2-Vim" class="headerlink" title="1.2 Vim"></a>1.2 Vim</h3><p><a href="https://coolshell.cn/articles/5426.html">https://coolshell.cn/articles/5426.html</a></p><p>Vim可以用来写一个函数<code>function</code>，比如<code>vim mcd.sh</code>（这个函数的功能是：创建一个目录 <code>$1</code> ，并且<code>cd</code>进去。）</p><div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/image-20211002222848501.png" class=""></div><p><code>source mcd.sh</code></p><p>用于找到此脚本的来源，并在shell中执行（execute）这个脚本然后加载（load）它。这样mcd函数已经在shell中定义，并且可以被调用。</p><div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/image-20211002223200503.png" class=""></div><h4 id="命令的输出和返回码："><a href="#命令的输出和返回码：" class="headerlink" title="命令的输出和返回码："></a>命令的输出和返回码：</h4><p>命令通常使用 STDOUT来返回输出值，使用STDERR 来返回错误及错误码，便于脚本以更加友好的方式报告错误。 返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生。</p><p>退出码可以搭配&amp;&amp; (与操作符) 和 || (或操作符)使用，用来进行条件判断，决定是否执行其他程序。它们都属于短路<a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">运算符</a>（short-circuiting）。 </p><p>同一行的多个命令可以用 ; 分隔。 程序 true 的返回码永远是0，false 的返回码永远是1。</p><p>举例：</p><div style="width:67%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/image-20211002223426860.png" class=""></div><h4 id="使用变量接收命令的输出："><a href="#使用变量接收命令的输出：" class="headerlink" title="使用变量接收命令的输出："></a>使用变量接收命令的输出：</h4><p>以变量的形式获取一个命令的输出，这可以通过 命令替换 (command substitution)实现——<code>$()</code>。</p><p>当您通过 <code>$( CMD )</code> 这样的方式来执行CMD 这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行 <code>for file in $(ls)</code> ，shell首先将调用<code>ls</code> ，然后遍历得到的这些返回值。</p><p>举例：</p><div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/wps7AB3.tmp.jpg" class=""></div> <h3 id="进程替换："><a href="#进程替换：" class="headerlink" title="进程替换："></a><strong>进程替换：</strong></h3><p>还有一个冷门的类似特性是 进程替换（process substitution）， <code>&lt;( CMD )</code> 会执行 CMD 并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code> 替换成临时文件名。这在我们希望返回值通过<strong>文件</strong>而不是<strong>STDIN</strong>传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 foo 和 bar 中文件的区别。</p><p>举例：</p><div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/wps14A0.tmp.jpg" class=""></div> <p>这里先ls当前目录并将其放入一个临时文件夹，然后对父目录做同样的事情，最后将他们串联起来。</p><div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/image-20211002231250545.png" class=""></div> <p>注意：<br>        <code>\$</code>0 将替换为脚本名，<code>$#</code> 将被替换为参数的个数，<code>$$</code>将为当前脚本的进程识别码，<code>$@</code> 所有参数，<code>$?</code>为前一个命令的返回码。<br>        <code>grep foobar “$file” &gt; /dev/null 2&gt; /dev/null</code> 对于这条命令的返回值和错误码是多少我们并不关注，我们只关注错误码是否为0。故需要重定向两个参数，即STDOUT和STDERR。(<code>2&lt;</code>代表重定向第二个参数的输出)<br>        比较运算符：-ne 表示不等于</p><p>在条件语句中，我们比较 <code>$?</code> 是否等于0。 Bash实现了许多类似的比较操作，您可以查看 <a href="https://man7.org/linux/man-pages/man1/test.1.html">test 手册</a>(man test)。 在bash中进行比较时，尽量使用双方括号 <code>[[ ]]</code> 而不是单方括号 <code>[ ]</code>，这样会降低犯错的几率，尽管这样并不能兼容 sh。</p><p>运行结果：</p><div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/wps3B7A.tmp.jpg" class=""></div> <p> 注意：</p><ul><li>运行脚本：<code>./脚本名</code></li><li>即使脚本只需要一个参数，可以连续加上多个参数以直接多次运行。</li></ul><h3 id="shell的通配-globbing-："><a href="#shell的通配-globbing-：" class="headerlink" title="shell的通配(globbing)："></a><strong>shell的通配(globbing)：</strong></h3><h4 id="1-通配符"><a href="#1-通配符" class="headerlink" title="1. 通配符"></a>1. 通配符</h4><p>当你想要利用通配符进行匹配时，你可以分别使用 ? 和 * 来匹配一个或任意个字符。例如，对于文件foo, foo1, foo2, foo10 和 bar, <code>rm foo?</code>这条命令会删除foo1 和 foo2 ，而<code>rm foo*</code> 则会删除除了bar之外的所有文件。</p><p>举例：<br><code>ls *.sh</code><br><code>ls project?  [project1, project2, project3]</code></p><div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/image-20211002231903454.png" class=""></div> <p>注意一下 * 和 ? 的不同。</p><h4 id="2-花括号"><a href="#2-花括号" class="headerlink" title="2. 花括号"></a>2. 花括号</h4><p>当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">convert image.png image.jpg <span class="comment"># 将png文件转化为jpg格式</span></span><br><span class="line"><span class="comment"># 可以这样写： </span></span><br><span class="line">convert image.{png,jpg}</span><br></pre></td></tr></tbody></table></figure><p>一些例子：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cp /path/to/project/{foo,bar,baz}.sh /newpath</span><br><span class="line"><span class="comment"># 会展开为</span></span><br><span class="line">cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath</span><br><span class="line"><span class="comment"># 注意这里相当于是将project目录下的三个后缀为.sh的文件copy到/newpath</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以结合通配使用</span></span><br><span class="line">mv *{.py,.sh} folder</span><br><span class="line"><span class="comment"># 会移动所有 \*.py 和 \*.sh 文件</span></span><br></pre></td></tr></tbody></table></figure><ul><li><strong>cp结合花括号使用：</strong></li></ul><div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/wps5436.tmp.jpg" class=""></div> <ul><li><strong>touch结合花括号使用：</strong></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="comment"># 在两个文件夹下批量创建相同的文件</span></span><br><span class="line">mkdir foo bar</span><br><span class="line"><span class="comment"># 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件</span></span><br><span class="line">touch {foo,bar}/{a..h}</span><br></pre></td></tr></tbody></table></figure><p><strong>输出：</strong></p><div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/wps5437.tmp.jpg" class=""></div> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="comment"># 比较文件夹 foo 和 bar 中包含文件的不同</span></span><br><span class="line">touch foo/x bar/y </span><br><span class="line">diff &lt;(ls foo) &lt;(ls bar)</span><br></pre></td></tr></tbody></table></figure><p><strong>输出：</strong></p><div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/wps5438.tmp.jpg" class=""></div> <p>另外，如果一个命令中包含两个花括号，那么它将扩展 n*m 次。</p><h2 id="1-3-shell脚本的编写"><a href="#1-3-shell脚本的编写" class="headerlink" title="1.3 shell脚本的编写"></a>1.3 shell脚本的编写</h2><h3 id="1-3-1-Magic-Line：-shebang-usr-local-bin-python"><a href="#1-3-1-Magic-Line：-shebang-usr-local-bin-python" class="headerlink" title="1.3.1 Magic Line： shebang  #!/usr/local/bin/python"></a>1.3.1 Magic Line： shebang  <code>#!/usr/local/bin/python</code></h3><p>仅仅是完成一个逆序输出输入的脚本：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/local/bin/python</span></span><br><span class="line">import sys</span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> reversed(sys.argv[1:]):</span><br><span class="line"><span class="built_in">print</span>(arg)</span><br></pre></td></tr></tbody></table></figure><div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/wpsB1B6.tmp.jpg" class=""></div> <p>但是这里是以python3的解释器来运行的，我们更加希望shell能够运行它。而shell知道应该使用python的解释器来运行这个程序正是因为第一行。</p><p><strong>shebang 行</strong>中使用的 <a href="https://man7.org/linux/man-pages/man1/env.1.html">env</a> 命令会利用环境变量中的程序来解析该脚本，这样就提高脚本的可移植性。env 会利用PATH 环境变量来进行定位。 例如，使用了env的shebang看上去是这样的 <code>#!/usr/bin/env python</code>。</p><p><strong>补充：</strong></p><p>但是上例中，运行python脚本的时候，即使加了shebang行，也不能直接运行（好吧，好像可以直接运行了）。运行python脚本有三种方法：</p><ul><li><p>方法1：python3 文件名 参数 （eg. python3 script.py 1 2 3 4）</p></li><li><p>方法2：加上shebang行：<code>#!/usr/bin/python3</code> 或 <code>#!/usr/bin/env python3</code></p><pre><code>    运行时：直接 script.py 1 2 3 4 (env - run a program in a modified environment)</code></pre><p>​        推荐 <code>#!/usr/bin/env python3</code>，因为通过/usr/bin/env 运行程序，用户不需要去寻找程序在系统中的位置（因为在不同的系统，命令或程序存放的位置可能不同，不一定一定在/usr/bin里，比如可能在/usr/local/bin中），<strong>只要程序在你的$PATH中就可以</strong>；</p><p>​        通过/usr/bin/env 运行程序另一个好处是，它会根据你的环境寻找并运行默认的版本，提供灵活性。</p><p>​        不好的地方是，有可能在一个多用户的系统中，别人在你的$PATH中放置了一个bash，可能出现错误。</p><p>​        大部分情况下，/usr/bin/env是优先选择的，因为它提供了灵活性，特别是你想在不同的版本下运行这个脚本；而指定具体位置的方式<code>#! /usr/bin/bash</code>，在某些情况下更安全，因为它限制了代码注入的可能。</p></li><li><p>方法3： chmod +x 文件名 （eg. chmod +x script.py）</p><pre><code>        文件名 参数         （eg. script.py 1 2 3 4）</code></pre><p>关于 chmod：</p><div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/wps8555.tmp.jpg" class=""></div> </li></ul><h3 id="1-3-2-Shellcheck可以帮助debug"><a href="#1-3-2-Shellcheck可以帮助debug" class="headerlink" title="1.3.2 Shellcheck可以帮助debug"></a>1.3.2 Shellcheck可以帮助debug</h3><div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/image-20211002234458205.png" class=""></div> <p>shell函数和脚本有如下一些不同点：</p><ul><li>函数只能用与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li><li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li><li>函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 <a href="httsp://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a> 将环境变量导出，并将值传递给环境变量。</li><li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。</li></ul><h2 id="2-Shell-tools"><a href="#2-Shell-tools" class="headerlink" title="2. Shell tools"></a>2. Shell tools</h2><h3 id="2-1-查看命令的使用"><a href="#2-1-查看命令的使用" class="headerlink" title="2.1 查看命令的使用"></a>2.1 查看命令的使用</h3><p>使用 <code>man command</code>，或者：简介工具<a href="https://tldr.sh/">tldr</a></p><h3 id="2-2-查找文件"><a href="#2-2-查找文件" class="headerlink" title="2.2 查找文件"></a>2.2 查找文件</h3><h4 id="2-2-1-find-命令"><a href="#2-2-1-find-命令" class="headerlink" title="2.2.1 find 命令"></a>2.2.1 find 命令</h4><p>程序员们面对的最常见的重复任务就是查找文件或目录。所有的类UNIX系统都包含一个名为 <a href="https://man7.org/linux/man-pages/man1/find.1.html"><code>find</code></a>的工具，它是shell上用于查找文件的绝佳工具。<code>find</code>命令会递归地搜索符合条件的文件，例如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有名称为src的文件夹</span></span><br><span class="line">find . -name src -<span class="built_in">type</span> d</span><br><span class="line"><span class="comment"># 查找所有文件夹路径中包含test的python文件</span></span><br><span class="line">find . -path <span class="string">'*/test/*.py'</span> -<span class="built_in">type</span> f</span><br><span class="line"><span class="comment"># 查找前一天修改的所有文件</span></span><br><span class="line">find . -mtime -1</span><br><span class="line"><span class="comment"># 查找所有大小在500k至10M的tar.gz文件</span></span><br><span class="line">find . -size +500k -size -10M -name <span class="string">'*.tar.gz'</span></span><br></pre></td></tr></tbody></table></figure><p>除了列出所寻找的文件之外，find还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除全部扩展名为.tmp 的文件</span></span><br><span class="line">find . -name <span class="string">'*.tmp'</span> -<span class="built_in">exec</span> rm {} \;</span><br><span class="line"><span class="comment"># 查找全部的 PNG 文件并将其转换为 JPG</span></span><br><span class="line">find . -name <span class="string">'*.png'</span> -<span class="built_in">exec</span> convert {} {}.jpg \;</span><br></pre></td></tr></tbody></table></figure><ul><li>按照后缀查找文件：</li></ul><div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/wps2061.tmp.jpg" class=""></div> <div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/image-20211002235051041.png" class=""></div> <ul><li>查找同时进行操作：</li></ul><div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/wps2063.tmp.jpg" class=""></div> <h4 id="2-2-2-fd-命令"><a href="#2-2-2-fd-命令" class="headerlink" title="2.2.2 fd 命令"></a>2.2.2 fd 命令</h4><p>尽管 <code>find</code> 用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式 <code>PATTERN</code> 的文件，您需要执行 <code>find -name '*PATTERN*'</code> (如果您希望模式匹配时是不区分大小写，可以使用<code>-iname</code>选项）</p><p>您当然可以使用alias设置别名来简化上述操作，但shell的哲学之一便是寻找（更好用的）替代方案。 记住，shell最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p><p>例如， <a href="https://github.com/sharkdp/fd"><code>fd</code></a> 就是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式<code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p><ul><li>关于locate：</li></ul><p>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p><p>这就要靠 <a href="https://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a> 了。 <code>locate</code> 使用一个由 <a href="https://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href="https://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a>每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>则只能通过文件名。 <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">here</a>有一个更详细的对比。</p><h3 id="2-3-查找文件内容（代码）"><a href="#2-3-查找文件内容（代码）" class="headerlink" title="2.3 查找文件内容（代码）"></a>2.3 查找文件内容（代码）</h3><h4 id="2-3-1-grep-命令"><a href="#2-3-1-grep-命令" class="headerlink" title="2.3.1 grep 命令"></a>2.3.1 grep 命令</h4><p>为了实现这一点，很多类UNIX的系统都提供了<a href="https://man7.org/linux/man-pages/man1/grep.1.html"><code>grep</code></a>命令，它是用于对输入文本进行匹配的通用工具。它是一个非常重要的shell工具，我们会在后续的数据清理课程中深入的探讨它。</p><p>grep 有很多选项，这也使它成为一个非常全能的工具。</p><ul><li><p>-C ：获取查找结果的上下文（Context）；</p></li><li><p>-v ：将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， grep -C 5 会输出匹配结果前后五行。</p></li><li><p>-R ：会递归地进入子目录并搜索所有的文本文件，——当需要搜索大量文件的时候使用。</p></li></ul><p><strong>grep替代品之一：<code>rg</code>（较为有效）</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有使用了 requests 库的文件</span></span><br><span class="line">rg -t py <span class="string">'import requests'</span><span class="comment"># 查找所有没有写 shebang 的文件（包含隐藏文件）</span></span><br><span class="line">rg -u --files-without-match <span class="string">"^#!"</span><span class="comment"># 查找所有的foo字符串，并打印其之后的5行</span></span><br><span class="line">rg foo -A 5<span class="comment"># 打印匹配的统计信息（匹配的行和文件的数量）</span></span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></tbody></table></figure><h3 id="2-4-查找shell命令"><a href="#2-4-查找shell命令" class="headerlink" title="2.4 查找shell命令"></a>2.4 查找shell命令</h3><h4 id="2-4-1-history命令"><a href="#2-4-1-history命令" class="headerlink" title="2.4.1 history命令"></a>2.4.1 history命令</h4><p><code>history</code> 命令允许您以程序员的方式来访问shell中输入的历史命令。这个命令会在标准输出中打印shell中的里面命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给 <code>grep</code> 进行模式搜索。 <code>history | grep find</code> 会打印包含find子串的命令。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | grep find</span><br><span class="line">从头开始：</span><br><span class="line"><span class="built_in">history</span> 1 | grep find</span><br></pre></td></tr></tbody></table></figure><h4 id="2-4-2-Ctrl-R"><a href="#2-4-2-Ctrl-R" class="headerlink" title="2.4.2 Ctrl+R"></a>2.4.2 Ctrl+R</h4><p>对于大多数的shell来说，您可以使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code> 后您可以输入子串来进行匹配，查找历史命令行。</p><p>反复按下就会在所有搜索结果中循环。在 <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh</a>中，使用方向键上或下也可以完成这项工作。</p><h4 id="2-4-3-fzf-工具"><a href="#2-4-3-fzf-工具" class="headerlink" title="2.4.3 fzf 工具"></a>2.4.3 fzf 工具</h4><p><code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a> 使用。<code>fzf</code> 是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p><p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。 这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell 创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前对shell命令进行补全。这一功能在 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p><div style="width:60%;margin:auto"></div> <div style="width:60%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/image-20211003000050315.png" class=""></div> <p>还可以支持交互式查找（还有默认的fzf）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他一些工具</span></span><br><span class="line">ls -R <span class="comment">#（递归列出目录结构）</span></span><br><span class="line">tree <span class="comment">#（树形目录结构）</span></span><br><span class="line">broot</span><br><span class="line">nnn</span><br><span class="line">auto jump </span><br><span class="line">sudo apt install ripgrep</span><br><span class="line"><span class="comment"># 关于grep</span></span><br><span class="line">shebang /r/n</span><br><span class="line">grep -C -v</span><br></pre></td></tr></tbody></table></figure><div style="width:70%;margin:auto"><img src="/2021/10/02/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-2-Tools-and-Scripting/wpsF216.tmp.jpg" class=""></div> ]]></content>
      
      
      <categories>
          
          <category> Missing semester </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Missing semester </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Missing Semester notes——Lecture 1 Course Overview</title>
      <link href="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/"/>
      <url>/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/</url>
      
        <content type="html"><![CDATA[<h1 id="Lecture-1-Course-Overview"><a href="#Lecture-1-Course-Overview" class="headerlink" title="Lecture 1 Course Overview"></a><strong>Lecture 1 Course Overview</strong></h1><blockquote><p>课程网址：<a href="https://missing-semester-cn.github.io/2020/course-shell/">https://missing-semester-cn.github.io/2020/course-shell/</a></p></blockquote><h2 id="内容概览"><a href="#内容概览" class="headerlink" title="内容概览"></a>内容概览</h2><ul><li><p>Linux和shell基本知识</p><ul><li>Linux文件系统（目录文件）</li><li>shell与环境变量</li></ul></li><li><p>Linux常用指令</p><ul><li>echo </li><li>man command 查看指令command的操作手册</li><li>control + L 清空终端并且回到顶部</li><li>目录操作：<br>cd<br>ls 查看目录内容<br>pwd 打印当前绝对路径（从环境变量查找）<br>cp 复制文件或目录<br>mv 移动文件<br>rm 删除文件<br>mkdir 创建目录<br>rmdir 删除目录</li><li>文件操作：<br>cat 从头打印文件内容<br>tail 只打印尾几行<br>head<br>tac 从最后一行开始打印</li><li>输入输出重定向<pre><code>command &gt; file 输出重定向到filecommand &lt; file 输入重定向到filecommand &gt;&gt; file 将输出以追加方式重定向到filepipe：command1 | command2 以左侧的输出作为右侧的输入</code></pre></li></ul></li><li><p>关于读写权限</p><p>sudo<br>the super user<br>sudo su<br>xdg-open 文件名.后缀 打开文件</p></li></ul><h2 id="一、Linux-和-shell-基本知识"><a href="#一、Linux-和-shell-基本知识" class="headerlink" title="一、Linux 和 shell 基本知识"></a>一、Linux 和 shell 基本知识</h2><p>​    很多都是以终端为中心的应用程序，例如：…，这些都存储在你的文件系统，而shell 可以利用一种搜索方式去帮助确定这些程序在哪里，它通过一个叫做环境变量的方式来做这件事 (<code>it does this through something called an invariant environment variable</code>)。</p><p>因此 shell 特别是 bourne-again shell 事实上是一种编程语言，用于提示你在某个位置是否可以运行一个程序。</p><blockquote><p>Particular environment variable 特定环境变量</p></blockquote><p>环境变量是启动 shell 程序时，不需要关注的一些变量，包括主目录（home directory）、用户名（username）、路径变量（path variable）等等。</p><h2 id="二、Linux常用指令"><a href="#二、Linux常用指令" class="headerlink" title="二、Linux常用指令"></a>二、Linux常用指令</h2><h3 id="echo-命令"><a href="#echo-命令" class="headerlink" title="echo 命令"></a>echo 命令</h3><p>显示机器上所有的 shell 将用于搜索程序的路径列表：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></tbody></table></figure><p>当我们要运行一个程序，比如说显示当前的日期 date，shell 会遍历所有这些目录直到找到一个文件或程序名字为 date 或echo。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> `date`</span><br></pre></td></tr></tbody></table></figure><blockquote><p>补充：清空文件内容的指令</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ &gt; filename</span><br><span class="line">$ <span class="built_in">echo</span> /dev/null &gt; filename</span><br><span class="line">$ cp /dev/null filename</span><br><span class="line">$ <span class="built_in">echo</span> &gt; filename</span><br></pre></td></tr></tbody></table></figure><p><code>https://linux.cn/article-8024-1.html</code></p></blockquote><p>如果我们想知道我们运行的是什么程序，有一个命令 called “<code>which</code>“ lets us do。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> <span class="built_in">echo</span></span><br></pre></td></tr></tbody></table></figure><div style="width:60%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-1.PNG" class=""></div><p>路径就是：a way to name the location of files on your computer.</p><blockquote><p>/：top of the file system</p><p>windows: 反斜杠 \，mac OS、Linux: 斜杠 /</p></blockquote><hr><h3 id="1-cd-命令"><a href="#1-cd-命令" class="headerlink" title="1. cd 命令"></a>1. cd 命令</h3><h4 id="1-1-相对路径（relative-path）"><a href="#1-1-相对路径（relative-path）" class="headerlink" title="1.1 相对路径（relative path）"></a>1.1 相对路径（relative path）</h4><p>相对路径是相对于当前工作目录。打印当前工作目录(present working director)</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br></pre></td></tr></tbody></table></figure><p>相对路径是相对于当前工作目录，因此也可以改变当前工作目录：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /... </span><br></pre></td></tr></tbody></table></figure><div style="width:60%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-2.PNG" class=""></div><h4 id="1-2-几个特殊的目录"><a href="#1-2-几个特殊的目录" class="headerlink" title="1.2 几个特殊的目录"></a>1.2 几个特殊的目录</h4><h5 id="1-2-1-dot-dot：-cd-转到当前目录的父目录"><a href="#1-2-1-dot-dot：-cd-转到当前目录的父目录" class="headerlink" title="1.2.1 dot dot： $ cd .. 转到当前目录的父目录"></a>1.2.1 dot dot： <code>$ cd ..</code> 转到当前目录的父目录</h5><div style="width:60%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-3.PNG" class=""></div><h5 id="1-2-1-dot-：-cd-转到当前目录的子目录"><a href="#1-2-1-dot-：-cd-转到当前目录的子目录" class="headerlink" title="1.2.1 dot ：$cd ./ 转到当前目录的子目录"></a>1.2.1 dot ：<code>$cd ./</code> 转到当前目录的子目录</h5><p><code>$ cd . /C</code> ：<code>will cd into the home directory under the current directory</code></p><div style="width:70%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-4.PNG" class=""></div> <p><code>because there is no home directory under the current directory I am now on which I change by doing the right cd.</code></p><h4 id="1-3-去到-home-目录-to-home-directory"><a href="#1-3-去到-home-目录-to-home-directory" class="headerlink" title="1.3 去到 home 目录 to home directory"></a>1.3 去到 home 目录 to home directory</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~ </span><br></pre></td></tr></tbody></table></figure><div style="width:60%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-5.PNG" class=""></div>  <p>注意此指令: <code>cd ~</code>回到<code>/home/jinstoz</code>目录下！！！</p><p> 也可以使用相对路径：</p><div style="width:80%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-6.PNG" class=""></div> <h4 id="1-4-去到刚刚的目录-back-to-the-previous-directory"><a href="#1-4-去到刚刚的目录-back-to-the-previous-directory" class="headerlink" title="1.4 去到刚刚的目录 back to the previous directory"></a>1.4 去到刚刚的目录 back to the previous directory</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> -</span><br></pre></td></tr></tbody></table></figure><p>所以这个命令经常用于在两个不同的目录之间来回切换。</p><h3 id="2-ls-命令"><a href="#2-ls-命令" class="headerlink" title="2. ls 命令"></a>2. ls 命令</h3><h4 id="2-1-显示当前目录下的所有文件-files-in-the-current-directory"><a href="#2-1-显示当前目录下的所有文件-files-in-the-current-directory" class="headerlink" title="2.1 显示当前目录下的所有文件 files in the current directory"></a>2.1 显示当前目录下的所有文件 files in the current directory</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br></pre></td></tr></tbody></table></figure><div style="width:80%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-7.PNG" class=""></div><h4 id="2-2-显示上一级目录的所有文件"><a href="#2-2-显示上一级目录的所有文件" class="headerlink" title="2.2 显示上一级目录的所有文件"></a>2.2 显示上一级目录的所有文件</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls .. </span><br></pre></td></tr></tbody></table></figure><h4 id="2-3-显示帮助文档"><a href="#2-3-显示帮助文档" class="headerlink" title="2.3 显示帮助文档"></a>2.3 显示帮助文档</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -- <span class="built_in">help</span></span><br></pre></td></tr></tbody></table></figure><div style="width:80%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-8.PNG" class=""></div> <h4 id="2-4-显示具体文件列表"><a href="#2-4-显示具体文件列表" class="headerlink" title="2.4 显示具体文件列表"></a>2.4 显示具体文件列表</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br></pre></td></tr></tbody></table></figure><div style="width:70%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-9.PNG" class=""></div> <div style="width:67%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-10.PNG" class=""></div><p>前缀带 <strong>D</strong> 或 <strong>d</strong> 代表这是一个目录而不是文件 (<code>D at the beginning of some of the these entries indicate that something is a directory</code>)：</p><div style="width:70%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-11.PNG" class=""></div> <p>无法cd或者打开指定文件或者目录是因为权限的缘故。</p><ul><li><p><strong>the first group of the three characters</strong>:  the owner of these file (jinstoz)</p></li><li><p><strong>the second group of the three characters</strong>:  the permissions for the group that owns this file (jinstoz group)</p></li><li><p><strong>the final group of the three characters</strong>:  the permissions for everyone else so anyone who’s not a user owner or a group owner</p></li></ul><div style="width:70%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-13.PNG" class=""></div>  <h3 id="3-mv-命令（移动文件，兼具修改文件名）"><a href="#3-mv-命令（移动文件，兼具修改文件名）" class="headerlink" title="3. mv 命令（移动文件，兼具修改文件名）"></a>3. mv 命令（移动文件，兼具修改文件名）</h3><p>(move 移动文件，给出现在路径和目标路径，可以改变location and its name) 可参考：<a href="https://www.runoob.com/linux/linux-comm-mv.html">https://www.runoob.com/linux/linux-comm-mv.html</a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv textfile.txt fool.txt<span class="comment"># 给 textfile.txt 重命名为 fool.txt</span></span><br></pre></td></tr></tbody></table></figure><div style="width:70%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-14.PNG" class=""></div>  <div style="width:70%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-15.PNG" class=""></div>  <h3 id="4-cp-命令（复制文件，兼具修改文件名）"><a href="#4-cp-命令（复制文件，兼具修改文件名）" class="headerlink" title="4. cp 命令（复制文件，兼具修改文件名）"></a>4. cp 命令（复制文件，兼具修改文件名）</h3><p>(two arguments：复制的路径和复制去的路径)</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp textfile.txt ../foo.txt<span class="comment"># 将 textfile.txt 复制到父目录并且重命名为 foo</span></span><br></pre></td></tr></tbody></table></figure><div style="width:60%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-16.PNG" class=""></div>  <div style="width:70%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-17.PNG" class=""></div>  <h3 id="5-rm-命令（删除文件remove）"><a href="#5-rm-命令（删除文件remove）" class="headerlink" title="5. rm 命令（删除文件remove）"></a>5. rm 命令（删除文件remove）</h3><div style="width:60%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-18.PNG" class=""></div>  <p><code>rm</code> 只能删除文件，因为不具有递归删除目录下文件的功能（所以不能删除目录）。</p><blockquote><p>in Linux, default not recursive：Linux下默认不是递归的 </p></blockquote><h3 id="6-rmdir-命令（删除空目录）"><a href="#6-rmdir-命令（删除空目录）" class="headerlink" title="6. rmdir 命令（删除空目录）"></a>6. rmdir 命令（删除<u>空目录</u>）</h3><p>要求空目录的原因：<code>empty：to be a safety mechanism</code> 这是一种安全机制，防止误删。</p><h3 id="7-mkdir-命令（创建新目录）"><a href="#7-mkdir-命令（创建新目录）" class="headerlink" title="7. mkdir 命令（创建新目录）"></a>7. mkdir 命令（创建新目录）</h3><p>对于 Linux 命令，要多注意字符串中的空格：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir My Photos <span class="comment"># 这样会创建两个目录，one My，one Photos</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir <span class="string">"My Photos"</span> <span class="comment"># 这样就对了，转义空格或引用字符串</span></span><br></pre></td></tr></tbody></table></figure><h3 id="8-man-命令"><a href="#8-man-命令" class="headerlink" title="8. man 命令"></a>8. man 命令</h3><p><code>give the manual page of another programme</code>，举例：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man ls<span class="comment"># 可以获得类似ls -help的结果，但是更加清晰，方便阅读，而且末尾通常有范例。</span></span><br></pre></td></tr></tbody></table></figure><h3 id="9-ctrl-L"><a href="#9-ctrl-L" class="headerlink" title="9. ctrl + L"></a>9. ctrl + L</h3><p>清除终端并且返回顶部。</p><hr><p><em><strong>Things above are talked about isolated programs. The followings are about chaining files together.</strong></em></p><blockquote><p>Input stream：keyboard (default)</p><p>Output stream：terminal (default)</p></blockquote><hr><h3 id="10-lt-gt-输入输出重定向"><a href="#10-lt-gt-输入输出重定向" class="headerlink" title="10. < > 输入输出重定向"></a>10. &lt; &gt; 输入输出重定向</h3><p>The shell gives a way to rewire these streams, to change where the input or output programs are pointed by using the bracket signs &lt; and &gt;.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="comment"># 输入输出流重定向</span></span><br><span class="line">$ &lt; file </span><br><span class="line">$ &gt; file</span><br><span class="line">$ <span class="comment"># 左尖括号表示重新连接输入流到 file，右尖括号表示重新连接输出到此文件 Rewire the output of the preceding program into this file</span></span><br></pre></td></tr></tbody></table></figure><p>举例：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello &gt; hello.txt </span><br><span class="line">$ <span class="comment"># (这里使用的是相对路径，将会在当前目录下创建一个txt文件，文件名为 hello 并且文件内容为hello，此时输出被重新连接到hello.txt文件，故终端（default）上不会有输出)</span></span><br></pre></td></tr></tbody></table></figure><div style="width:60%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-19.PNG" class=""></div>  <h3 id="11-cat-命令（打印文件内容）"><a href="#11-cat-命令（打印文件内容）" class="headerlink" title="11. cat 命令（打印文件内容）"></a>11. cat 命令（打印文件内容）</h3><p><code>cat</code> 也可以输入输出重定向：</p><h4 id="11-1-cat-lt-hello-txt"><a href="#11-1-cat-lt-hello-txt" class="headerlink" title="11.1 cat < hello.txt"></a>11.1 <code>cat &lt; hello.txt</code></h4><div style="width:60%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-20.PNG" class=""></div>  <h4 id="11-2-cat-lt-hello-txt-gt-hello2-txt"><a href="#11-2-cat-lt-hello-txt-gt-hello2-txt" class="headerlink" title="11.2 cat < hello.txt > hello2.txt"></a>11.2 <code>cat &lt; hello.txt &gt; hello2.txt</code></h4><p><strong>输入输出流双向 rewired</strong>：shell 通过 <code>cat &lt;</code> 从 <code>hello.txt</code> 获取文本内容并且通过 <code>&gt;</code> 将内容打印到 <code>hello2.txt</code> 中。<code>（a copy of the original file）</code></p><div style="width:60%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-21.PNG" class=""></div>  <h3 id="12-gt-gt-追加"><a href="#12-gt-gt-追加" class="headerlink" title="12. >> 追加"></a>12. &gt;&gt; 追加</h3><p>将一个文件的内容追加写入另外一个文件，举例：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt; hello.txt &gt; hello2.txt<span class="comment"># 覆盖</span></span><br></pre></td></tr></tbody></table></figure><div style="width:60%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-22.PNG" class=""></div>   <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt; hello.txt &gt;&gt; hello2.txt <span class="comment"># 追加</span></span><br></pre></td></tr></tbody></table></figure><div style="width:60%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-23.PNG" class=""></div>  <h3 id="13-pipe"><a href="#13-pipe" class="headerlink" title="13. | (pipe)"></a>13. | (pipe)</h3><p>使得程序从左侧的输出，作为右侧的输入。举例：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l / <span class="comment"># 显示根目录下的所有文件</span></span><br></pre></td></tr></tbody></table></figure><p>如果只是想打印输出的最后一行：</p><h3 id="14-tail"><a href="#14-tail" class="headerlink" title="14. tail"></a>14. tail</h3><p>打印输出的最后一行</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -n1</span><br></pre></td></tr></tbody></table></figure><p>举例：tail 和 | (pipe) 结合起来就是：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  ls -l / | tail -n1<span class="comment"># ls 的输出作为 tail 的输入并且将 tail 的结果输出到 terminal（default）</span></span><br></pre></td></tr></tbody></table></figure><div style="width:60%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-24.PNG" class=""></div>   <blockquote><p><strong>注意：需要进行输入输出重定向的两个程序本身并不知道互相之间的关系（tail did not know about ls, ls did not know about tail），是 shell 设置了输入输出的重定向。</strong></p></blockquote><p>重定向 tail 的输出之后：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l / | tail -n1 &gt; ls.txt</span><br></pre></td></tr></tbody></table></figure><div style="width:60%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-25.PNG" class=""></div>   <blockquote><p>| pipe 也可以用于图像、视频（chromecast）</p></blockquote><h2 id="三、读写权限"><a href="#三、读写权限" class="headerlink" title="三、读写权限"></a>三、读写权限</h2><h3 id="l-文件-file-和目录-directory-的权限"><a href="#l-文件-file-和目录-directory-的权限" class="headerlink" title="l . 文件 file 和目录 directory 的权限"></a>l . 文件 file 和目录 directory 的权限</h3><h4 id="1-1-文件权限"><a href="#1-1-文件权限" class="headerlink" title="1.1 文件权限"></a>1.1 文件权限</h4><blockquote><p><strong>三种权限：read write execute（r-w-x）</strong></p><div style="width:60%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-26.PNG" class=""></div>  <pre><code>    r-x：表示已经读和运行，但是并没有权限只有读的权限没有写的权限（https://programskills.blog.csdn.net/article/details/105023305)</code></pre></blockquote><p>执行： <code>$ ls -l /usr/bin</code></p><div style="width:70%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-27.PNG" class=""></div>   <p>结果：大多数都 have the execute bit set even for people who are not the owner of the file，因为例如 echo 这样的文件，系统希望所有人可以运行（尽管不能读或写）。</p><h4 id="1-2-目录权限"><a href="#1-2-目录权限" class="headerlink" title="1.2 目录权限"></a>1.2 目录权限</h4><ul><li><p><em><strong>读（Read）</strong></em>：能否看到目录下文件的权限。</p></li><li><p><em><strong>写（Write）</strong></em>：<br>whether allowed to rename(重命名) create(创建) or remove(移动) files in that directory。（也就是说，如果对于文件有write right，但是对于文件所在目录没有write right，那么只能清空这个文件的内容，而不能删除它——因为这需要对目录本身做写操作）</p></li><li><p><em><strong>执行（execute）</strong></em>：<br>就是所谓的搜索。如果需要对某一个文件有读、写、运行的权限，也就是cd into a directory，那么必须拥有这个文件所在目录的所有父目录的execute（执行）权限，以及这个目录本身的execute permission。</p></li></ul><p>举例：<br>    比如要运行 <code>echo</code> 程序（<code>/root/usr/bin</code>），那么必须有 <code>/root/usr/bin</code> <u>每层目录的全部<strong>运行权限</strong></u>，否则 will not be able to enter the directory along the way。</p><h3 id="2-sudo-和-the-super-user"><a href="#2-sudo-和-the-super-user" class="headerlink" title="2. sudo 和 the super user"></a>2. sudo 和 the super user</h3><blockquote><p>This is something about how to use terminal more powerful~~.</p></blockquote><h4 id="2-1-notion：the-root-user"><a href="#2-1-notion：the-root-user" class="headerlink" title="2.1 notion：the root user"></a>2.1 notion：the root user</h4><ul><li><p>Just like the administrator users on Windows and <strong>its user ID is 0</strong>. </p></li><li><p><strong>Allow the root user do anything on the system</strong>.</p></li></ul><p>但是大多数情况下，我们一般使用其他身份（比如我以jinstoz的身份），因为如果一旦不小心运行了错误的指令或程序，可能会毁了这个系统。</p><p>但总有需要root user的操作，于是有了 <code>sudo</code>（do the following things as the super user）。</p><h4 id="2-2-sudo-命令"><a href="#2-2-sudo-命令" class="headerlink" title="2.2 sudo 命令"></a>2.2 sudo 命令</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /sys<span class="comment"># 内核参数</span></span><br></pre></td></tr></tbody></table></figure><div style="width:60%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-28.PNG" class=""></div>   <p>这些文件实际上不是我们电脑上的文件，这些是各种各样的内核参数（kernel parameters），只是以文件系统的形式展现出来。</p><p>下面看看class里的东西：<code>$ cd class</code></p><div style="width:70%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-29.PNG" class=""></div>   <p>这些是可以互动的设备类型（types of devices that i can interact with），或可以访问的所有线索等等。</p><blockquote><p><strong>再次注意：</strong></p><p>需要进行输入输出重定向的两个程序本身并不知道互相之间的关系（tail did not know about ls, ls did not know about tail），是 shell 设置了输入输出的重定向。</p></blockquote><p>所以：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">echo</span> 500 &gt; brightness</span><br><span class="line">$ <span class="comment"># 这里只是 shell 以 root 权限使用 echo 程序（参数是 echo 和 500，并且将其输出送到 brightness），但是，是 echo 程序打开 brightness 并且将 500 写入而不是 sudo 程序。所以这里是我（user：jinstoz）尝试打开 brightness 并且写入，这里会出现权限下降permission down error的问题。</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2-3-sudo-su-可以让-shell-成为-the-super-user"><a href="#2-3-sudo-su-可以让-shell-成为-the-super-user" class="headerlink" title="2.3 sudo su 可以让 shell 成为 the super user"></a>2.3 <code>sudo su</code> 可以让 shell 成为 the super user</h4><div style="width:60%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-30.PNG" class=""></div>   <p>变化：<code>jinstoz -&gt; root</code>, <code>$ -&gt; #</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo echo 500 &gt; brightness  # 此时这条指令不会出现权限下降</span></span><br><span class="line"><span class="comment"># exit  # 退出 root 权限</span></span><br></pre></td></tr></tbody></table></figure><p>不过不一定要获取 root 权限(因为使用root权限比较危险)，还可以使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 1060 | sudo tee brightness</span><br></pre></td></tr></tbody></table></figure><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><h4 id="xdg-open-文件名"><a href="#xdg-open-文件名" class="headerlink" title="xdg-open 文件名"></a><code>xdg-open 文件名</code></h4><p>打开目录下的任意格式文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xdg-open <span class="string">'Missing Semester'</span>.docx</span><br></pre></td></tr></tbody></table></figure><div style="width:80%;margin:auto"><img src="/2021/08/01/Missing-Semester-notes%E2%80%94%E2%80%94Lecture-1-Course-Overview/image-31.PNG" class=""></div>   <p>这里打开的文件名有空格，要用单引号括起来。</p><p><a href="https://blog.csdn.net/liweiminlining/article/details/51497866">https://blog.csdn.net/liweiminlining/article/details/51497866</a></p><p><a href="https://blog.csdn.net/u010853580/article/details/43406005">https://blog.csdn.net/u010853580/article/details/43406005</a></p><p>附：<a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash quoting</a>手册：</p><p><a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">https://www.gnu.org/software/bash/manual/html_node/Quoting.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Missing semester </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Missing semester </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github搭建博客记录</title>
      <link href="/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以往每遇到一些值得记录或者想要分享的内容时，都是拿word记录。但是渐渐东西多了之后，发现因为是留给自己看的，有时候就懒于叙述，显得庞杂无章。同时呢，网上也有很多氛围非常好的论坛，收录有很多厉害的博文，也考虑过在上面发表，也方便 follow the other bloggers。但是那些网站的写博界面总是让人很不满，自由度不高之外，还有广告推送；但是自己建站的成本有点高了，要购买域名、服务器，还要定期维护。毕竟只是用于记录和分享，于是，基于开源框架的 Hexo 等平台就自然而然地成为较优的选择啦。</p><p><a href="https://hexo.io/">Hexo</a> 是一种高效的静态网站生成框架，快速、简单且功能强大，可以说是搭建博客的首选框架之一。Hexo 基于 Node.js和 Git，可以通过 Markdown 语法来撰写你的博文，因此也能基本满足对于排版有着一定要求的 bloggers。同时它也有着较为完善的官方文档、较广的受众和及时的更新维护，使用过程中遇到的问题基本上都能得到解决。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>这篇文章主要是为了记录以下自己陆陆续续搭建博客的过程，过程中参考官方文档以及很多大佬的博文，后面会缀以引用，也方便读者去阅读，真的都写得很棒很清楚。</p><p>第二个目的呢，也是希望能够为想搭建自己的博客的同学提供一个小小的指导，这篇文章基本上尽我所能地详细概括了基本的建博流程，以及个人博客的定制和优化。希望能够帮到大家~</p><h2 id="一、博客搭建"><a href="#一、博客搭建" class="headerlink" title="一、博客搭建"></a>一、博客搭建</h2><h3 id="Hexo搭建步骤"><a href="#Hexo搭建步骤" class="headerlink" title="Hexo搭建步骤"></a><strong>Hexo搭建步骤</strong></h3><ul><li>1.<code>Git</code>的下载安装</li><li>2.<code>Node.js</code>的下载安装</li><li>3.<code>Hexo</code>的下载安装</li><li>4.<code>GitHub</code>创建个人仓库</li><li>5.生成本地<code>SSH</code>添加到<code>GitHub</code></li><li>6.将<code>Hexo</code>部署到<code>GitHub</code></li><li>7.个人域名的获取</li><li>8.发布文章</li></ul><h3 id="1-Git-的下载安装"><a href="#1-Git-的下载安装" class="headerlink" title="1. Git 的下载安装"></a>1. <strong>Git</strong> 的下载安装</h3><p><strong>Windows：</strong>下载 <strong>Git</strong> ，很多博客和教程指路可以去 <a href="https://git-scm.com/download/win">Git官网</a> 下载 <code>.exe</code> 文件，不过本地下载网速很慢，会出现异常中止(ˉ▽ˉ；)…推荐阿里的<a href="https://npm.taobao.org/mirrors/git-for-windows">镜像</a>，下载速度超快。进去选择自己要的版本点击下载即可。（ aliyun 每十分钟更新一次，应该都是最新版本）</p><p>安装 <strong>Git</strong> 时，安装选项基本全部默认。注意这一步 <code>Adjusting your PATH environment</code> 添加 <code>PATH</code> 路径，选择 <code>Git from the command line and also from 3rd-party software</code>，这样我们就可以直接在命令提示符里打开 <strong>Git</strong> 了。见下图：</p><div style="width:60%;margin:auto"><img src="/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-1.png" class=""></div><p><strong>Linux：</strong>最早的 <strong>Git</strong> 就是在 <strong>Linux</strong> 上编写的，只需：</p><figure class="highlight zsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></tbody></table></figure><p>安装完成后在命令提示符中输入<code>git --version</code>来查看一下版本验证是否安装成功。</p><h3 id="2-Node-的下载安装"><a href="#2-Node-的下载安装" class="headerlink" title="2. Node 的下载安装"></a>2. <strong>Node</strong> 的下载安装</h3><p><strong>Hexo</strong> 是基于 <strong>node.js</strong> 编写的，所以需要安装一下 <strong>node.js</strong> 和里面的 <strong>npm</strong> 工具。</p><p><strong>Windows：</strong>下载稳定版或者最新版都可以，下载<a href="http://nodejs.cn/download/">Node.js</a>，安装选项全部默认，一直 next。<br>最后安装好之后，按<code>Win+R</code>打开命令提示符或者在 git bash 中，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p><h3 id="3-Hexo-的下载安装"><a href="#3-Hexo-的下载安装" class="headerlink" title="3. Hexo 的下载安装"></a>3. <strong>Hexo</strong> 的下载安装</h3><p>前面 <strong>git</strong> 和 <strong>nodejs</strong> 安装好后，就可以安装 <strong>Hexo</strong> 了，你可以先创建一个文件夹<code>MyBlog</code>，用来存放自己的博客文件，然后<code>cd</code>到这个文件夹下（或者在这个文件夹下直接右键<code>git bash</code>打开）。比如我的博客文件都存放在<code>C:\Users\username\MyBlog\</code>目录下。在该目录下右键点击<code>Git Bash Here</code>，打开 <strong>Git</strong> 的控制台窗口，以后我们所有的操作都在 <strong>Git</strong> 控制台进行，就不用<strong>windows</strong> 自带的 <strong>cmd</strong> 了。</p><p>定位到该目录下，输入<code>npm install hexo-cli -g</code>安装 <strong>Hexo</strong>。可能会有几个报错，无视它就行。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></tbody></table></figure><p>安装完后输入<code>hexo -v</code>验证是否安装成功。至此 <strong>Hexo</strong> 就安装完了。</p><p>接下来初始化一下 <strong>Hexo</strong> ,即初始化我们的网站，输入<code>hexo init</code>初始化文件夹。</p><figure class="highlight zsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init hexoblog</span><br></pre></td></tr></tbody></table></figure><p>这个<code>hexoblog</code>可以自己取什么名字都行，然后，接着输入<code>npm install</code>来安装必备的组件。</p><figure class="highlight zsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./hexoblog      //进入这个hexoblog文件夹</span><br><span class="line">npm install</span><br></pre></td></tr></tbody></table></figure><p>初始化完成后，博客文件夹<code>hexoblog</code>目录下有：</p><ul><li><code>node_modules</code>  依赖包</li><li><code>public</code> 存放生成的页面</li><li><code>scaffolds</code> 生成文章的一些模板</li><li><code>source</code> 用来存放你的文章</li><li><code>themes</code> 主题</li><li><code>_config.yml</code> 博客的配置文件</li></ul><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate //简写为 hexo g</span><br><span class="line">hexo server //简写为 hexo s</span><br></pre></td></tr></tbody></table></figure><p>然后浏览器中打开<a href="http://localhost:4000/">网址</a> <code>http://localhost:4000/</code>，就可以看到我们的博客啦，不要乱按<code>ctrl+c</code> <span class="github-emoji"><span>😏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>~，本地原始效果如下：</p><div style="width:80%;margin:auto"><img src="/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-2.png" class=""></div><p>按<code>ctrl+c</code>关闭本地服务器。</p><h3 id="4-Github-创建个人仓库"><a href="#4-Github-创建个人仓库" class="headerlink" title="4. Github 创建个人仓库"></a>4. <strong>Github</strong> 创建个人仓库</h3><p>打开 <a href="https://github.com/">Github</a>，新建一个项目仓库<code>New repository</code>，如下所示：</p><div style="width:80%;margin:auto"><img src="/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-3.PNG" class=""></div><p>输入自己的项目名称 <code>repository-name</code>，最好为用户名<code>username</code>加<code>.github.io</code>后缀，即<code>username.github.io</code>，且<code>README</code>初始化也要勾上。比如我的就是<code>Jinstorm.github.io</code>，这样部署之后<code>https://repository-name/</code>就是你的博客地址，比如我的就是 <a href="https://jinstorm.github.io/%E3%80%82">https://Jinstorm.github.io/。</a><br>否则的话，通过<code>https://username.github.io/repository-name</code> 访问也可。</p><h3 id="5-生成-SSH-添加到-Github"><a href="#5-生成-SSH-添加到-Github" class="headerlink" title="5. 生成 SSH 添加到 Github"></a>5. 生成 <strong>SSH</strong> 添加到 <strong>Github</strong></h3><p>生成<code>SSH</code>添加到 <strong>Github</strong>，连接 <strong>Github</strong> 与本地。</p><p>右键 <code>git bash here</code>，然后输入下面指令：</p><figure class="highlight zsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"yourname"</span></span><br><span class="line">git config --global user.email <span class="string">"youremail"</span></span><br></pre></td></tr></tbody></table></figure><p>这里的<code>yourname</code>输入你的 <strong>Github</strong> 用户名，<code>youremail</code>输入你 <strong>Github</strong> 的邮箱。这样 <strong>Github</strong> 才能知道你是不是对应它的账户。例如我的：</p><figure class="highlight zsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"Jinstorm"</span></span><br><span class="line">git config --global user.email <span class="string">"snowstorm.xjtu.edu.cn"</span></span><br></pre></td></tr></tbody></table></figure><p>可以用以下两条，检查一下你有没有输对</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></tbody></table></figure><p>接着就是创建 <strong>SSH</strong>：</p><blockquote><p>SSH：安全外壳协议，最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。简单来说，SSH就是一个密钥对，公钥和私钥，公钥是用于数据加密的，私钥是用于解密公钥加密的数据的。<br>这里 id_rsa 是私钥，不能随便给别人看的；id_rsa.pub 是公钥，是可以给别人看的。把这个公钥放在 Github 上，这样当公钥和私钥相互匹配的时候，才能通过 git 操作你的博客。</p></blockquote><p>生成 <strong>SSH</strong> 公钥：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"youremail"</span></span><br></pre></td></tr></tbody></table></figure><p>生成的中间步骤一直回车即可，都可以是默认的。</p><p>此时已经生成了<code>.ssh</code>的文件夹，可以通过文件资源管理器或者如下指令找到：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></tbody></table></figure><p><code>cat</code>是 <strong>Linux</strong> 指令（英文全拼：concatenate），用于连接文件并打印到标准输出设备上，这里就是打印到你的 bash 终端上。将输出的内容全部复制。</p><p>打开 <strong>Github</strong>，点击头像下的 <strong>Settings</strong>，点击侧边栏的 <strong>SSH and GPG keys</strong>，新建一个 <strong>SSH</strong>，名字 title 任意取，把你刚刚复制的<code>id_rsa.pub</code>里面的信息粘贴进 key，完成添加。</p><div style="width:80%;margin:auto"><img src="/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-4.PNG" class=""></div><p>在<code>git bash</code>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。</p><div style="width:75%;margin:auto"><img src="/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-5.png" class=""></div><h3 id="6-将-Hexo-部署到-Github"><a href="#6-将-Hexo-部署到-Github" class="headerlink" title="6. 将 Hexo 部署到 Github"></a>6. 将 <strong>Hexo</strong> 部署到 <strong>Github</strong></h3><p>接下来就是将 <strong>Hexo</strong> 生成的文章部署到 <strong>Github</strong> 上。打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。</p><p>修改最后一行的配置：</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/Jinstorm/Jinstorm.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></tbody></table></figure><p>将<code>repository</code>修改为你自己的 <strong>Github</strong> 项目地址即可，就是部署时告诉工具，将生成网页通过 git 方式上传到你对应的仓库中。这个时候需要先安装部署的命令<code>hexo-deployer-git</code>，这样你才能用命令部署到 <strong>Github</strong>。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure><p>然后运行以下指令：（三个常用指令）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>其中 <code>hexo clean</code>清除了你之前生成的东西。 <code>hexo generate</code>顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写 ，<code>hexo deploy</code>部署文章，可以用<code>hexo d</code>缩写。</p><p>第一次部署到 <strong>Github</strong> 时可能需要输入你的 <strong>Github</strong> 的 username 和 password 来确保连接到你的 Github 账户。部署成功之后，就可以在<code>https://username.github.io/</code>看到你的博客了！</p><p>（部署成功：bash终端响应的末尾会显示如：<code>INFO  Deploy done: git</code>；如果不成功，大多是因为 Github 的访问不太稳定，多来几次~）</p><h3 id="7-个人域名的获取"><a href="#7-个人域名的获取" class="headerlink" title="7. 个人域名的获取"></a>7. 个人域名的获取</h3><p>到阿里云或者腾讯云购买域名即可。~</p><p>然后实名认证后进入腾讯云控制台，点云解析进去，找到你刚买的域名，点进去添加两条解析记录。然后打开你的 <strong>Github</strong> 博客项目，点击<code>settings</code>，拉到下面<code>Custom domain</code>处，填上你自己的域名，保存。这时候你的项目根目录应该会出现一个名为<code>CNAME</code>的文件了。如果没有的话，打开你本地博客<code>source</code>目录，我的是<code>\hexoblog\source</code>，新建<code>CNAME</code>文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行<code>hexo g</code>、<code>hexo d</code>上传到 <strong>Github</strong>。</p><p>过不了多久，再打开你的浏览器，输入你自己的域名，就可以看到搭建的网站啦！</p><h3 id="8-发布文章"><a href="#8-发布文章" class="headerlink" title="8. 发布文章"></a>8. 发布文章</h3><p>首先在博客根目录下右键打开<code>git bash</code>，安装一个扩展<code>npm i hexo-deployer-git</code>。</p><p>输入<code>hexo new post "article title"</code>，就可以新建一篇名字为<code>article title</code>的文章。然后打开<code>hexoblog\source\_posts</code>的目录，可以发现下面生成了一个<code>.md</code>文件，用来存放你的文章文件。你可以直接在 <strong>vscode</strong> 或者 <strong>Typora</strong> 里编写 <strong>markdown</strong> 文件，可以实时预览，也可以用其他文本编辑器编写。编写完 markdown 文件后，博客根目录下 bash 输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到 <strong>Github</strong> 上。</p><p>注意将 <strong>Github</strong> 中的仓库分支 branch 改为 master，这样就能看到部署的内容了：</p><div style="width:80%;margin:auto"><img src="/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-6.PNG" class=""></div><p>这时打开你的<code>username.github.io</code>主页就能看到发布的文章啦。</p><h2 id="二、个人博客的定制"><a href="#二、个人博客的定制" class="headerlink" title="二、个人博客的定制"></a>二、个人博客的定制</h2><h3 id="1-Hexo-博客的目录文件"><a href="#1-Hexo-博客的目录文件" class="headerlink" title="1. Hexo 博客的目录文件"></a>1. <strong>Hexo</strong> 博客的目录文件</h3><h4 id="1-1-目录结构"><a href="#1-1-目录结构" class="headerlink" title="1.1 目录结构"></a>1.1 目录结构</h4><p>在你的博客的根目录下，应该包含：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- node_modules </span><br><span class="line">- public </span><br><span class="line">- scaffolds </span><br><span class="line">- source </span><br><span class="line">- _data </span><br><span class="line">- _posts </span><br><span class="line">- about </span><br><span class="line">- archives </span><br><span class="line">- categories </span><br><span class="line">- friends </span><br><span class="line">- tags </span><br><span class="line">- themes</span><br></pre></td></tr></tbody></table></figure><p><code>node_modules</code>是<code>node.js</code>各种库的目录，<code>public</code>是生成的网页文件目录，<code>scaffolds</code>里面就三个文件，存储着新文章和新页面的初始设置，<code>source</code>是我们最常用到的一个目录，里面存放着文章、各类页面、图像等文件，<code>themes</code>存放着主题文件，一般也用不到。</p><p>平时写文章只需要关注<code>source/_posts</code>这个文件夹就行了。</p><h4 id="1-2-Layout-布局"><a href="#1-2-Layout-布局" class="headerlink" title="1.2 Layout 布局"></a>1.2 Layout 布局</h4><h5 id="1-2-1-post"><a href="#1-2-1-post" class="headerlink" title="1.2.1 post"></a>1.2.1 post</h5><p>当你想写一篇新文章，使用代码：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new XXX</span><br></pre></td></tr></tbody></table></figure><p>它其实默认使用的是<code>post</code>这个布局，也就是在<code>source</code>文件夹下的<code>_post</code>里面。</p><p><strong>Hexo</strong> 有三种默认布局：<code>post</code>、<code>page</code>和<code>draft</code>，它们分别对应不同的路径，而你自定义的其他布局和<code>post</code>相同，都将储存到<code>source/_posts</code>文件夹。</p><p>而 new 这个命令其实是：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></tbody></table></figure><p>只不过这个<code>layout</code>默认是<code>post</code>罢了。这个命令会在<code>_post</code>文件夹下新建一个<code>XXX.md</code>文件和一个同名的文件夹，文件夹主要是用于存放和这篇文章相关的图片等文件啦。</p><h5 id="1-2-2-page"><a href="#1-2-2-page" class="headerlink" title="1.2.2 page"></a>1.2.2 page</h5><p>如果你想另起一页，那么可以使用</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page newpage</span><br></pre></td></tr></tbody></table></figure><p>系统会自动给你在<code>source</code>文件夹下创建一个<code>newpage</code>文件夹，以及<code>newpage</code>文件夹中的<code>index.md</code>，这样你访问的<code>newpage</code>对应的链接就是 <a href="http://xxx.xxx/newpage%E3%80%82">http://xxx.xxx/newpage。</a></p><h5 id="1-2-3-draft"><a href="#1-2-3-draft" class="headerlink" title="1.2.3 draft"></a>1.2.3 draft</h5><p><code>draft</code>是草稿的意思，也就是你如果想写文章，又暂时不希望被看到，那么可以</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft newdraft</span><br></pre></td></tr></tbody></table></figure><p>这样会在<code>source/_draft</code>中新建一个<code>newdraft.md</code>文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server --draft</span><br></pre></td></tr></tbody></table></figure><p>在本地端口中开启服务预览。</p><p>如果你的草稿文件写完了，想要发表到<code>post</code>中，</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish draft newdraft</span><br></pre></td></tr></tbody></table></figure><p>就会自动把<code>newdraft.md</code>发送到<code>post</code>中</p><h3 id="2-更换-Hexo-的主题"><a href="#2-更换-Hexo-的主题" class="headerlink" title="2. 更换 Hexo 的主题"></a>2. 更换 <strong>Hexo</strong> 的主题</h3><p>Hexo的主题有很多，<a href="https://hexo.io/themes/">Hexo的官方主题库</a>。</p><p>另外，<a href="https://fontawesome.com/">这里</a>官方图标库，可以找到很多图标 icons，可以下载你需要的格式。</p><h3 id="3-Hexo-主题的个性化"><a href="#3-Hexo-主题的个性化" class="headerlink" title="3. Hexo 主题的个性化"></a>3. <strong>Hexo</strong> 主题的个性化</h3><ul><li>显示图片</li><li>在右上角或者左上角实现fork me on github</li><li>添加RSS</li><li>修改文章内链接文本样式</li><li>博文压缩</li><li>修改``代码块自定义样式</li><li>侧边栏社交小图标设置</li><li>主页文章添加阴影效果</li><li>网站访问量</li><li>网站字数统计</li><li>设置网站的图标Favicon</li><li>实现统计功能</li><li>添加顶部加载条</li><li>在文章底部增加版权信息</li><li>隐藏网页底部powered By Hexo / 强力驱动</li><li>文章加密访问</li><li>添加jiathis分享</li><li>博文置顶</li><li>修改字体大小</li></ul><p>（考虑另外写一篇来记录）</p><p>图片的显示：</p><p>文章：<a href="https://hexo.io/zh-cn/docs/asset-folders">https://hexo.io/zh-cn/docs/asset-folders</a></p><h2 id="三、个人博客的优化"><a href="#三、个人博客的优化" class="headerlink" title="三、个人博客的优化"></a>三、个人博客的优化</h2><h3 id="1-Github-和-Coding-双线部署"><a href="#1-Github-和-Coding-双线部署" class="headerlink" title="1. Github 和 Coding 双线部署"></a>1. <strong>Github</strong> 和 <strong>Coding</strong> 双线部署</h3><p>由于 <strong>Github</strong> 的网站在国外，国内访问多多少少都不太稳定，为了方便国内用户访问你的个人博客，也是出于国内外访问分流的考虑，于是可以考虑双线部署。另外，相比于 <strong>Github</strong> 部署，<strong>Coding</strong> 还可以提交百度收录，这样别人通过百度搜索引擎可以搜索到你的博客。</p><blockquote><p><a href="https://coding.net/">Coding</a> 是一个类似于 Github 的一站式软件研发协作管理平台，有必要说明的是，新版 Coding 现已经被腾讯云收购，静态页面的部署依赖于腾讯云的对象存储功能，虽然对于新用户会提供几个月的免费流量包，但是之后就会 <strong>开始收费</strong>。</p></blockquote><h4 id="注册-Coding"><a href="#注册-Coding" class="headerlink" title="注册 Coding"></a>注册 <strong>Coding</strong></h4><p>如果没有 <strong>Coding</strong> 的账号，先去<a href="https://coding.net/">Coding</a>官网注册一个。通过微信扫码绑定你的腾讯云账号即可，不过微信要绑定过你的银行卡。值得注意的是，注册时的<strong>团队名</strong>就是你的<strong>用户名</strong>，后面会用到。</p><p>需要实名认证：右上角头像——团队管理——团队设置——高级设置——实名认证。</p><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>这里和 Github 项目创建大同小异，左侧点击<strong>项目</strong>，然后右上角<strong>创建项目</strong>。</p><div style="width:80%;margin:auto"><img src="/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-7.PNG" class=""></div><p>选择 <strong>项目模板</strong>——<strong>全功能DevOps项目</strong></p><div style="width:80%;margin:auto"><img src="/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-8.PNG" class=""></div><p>填写项目基本信息。项目名称可以任意填写，项目描述可有可无，需要注意的是<strong>项目标识</strong>和你的项目地址有关，可以填写你的注册时的用户名（即团队名）。</p><div style="width:80%;margin:auto"><img src="/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-9.PNG" class=""></div><h4 id="创建代码仓库"><a href="#创建代码仓库" class="headerlink" title="创建代码仓库"></a>创建代码仓库</h4><div style="width:80%;margin:auto"><img src="/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-10.PNG" class=""></div><p>仓库名称和你的用户名一致即可，可以勾选 README 文件，一般选择私有仓库，其他默认，完成创建。</p><h4 id="将-SSH-添加到-Github"><a href="#将-SSH-添加到-Github" class="headerlink" title="将 SSH 添加到 Github"></a>将 <strong>SSH</strong> 添加到 <strong>Github</strong></h4><p>此步骤同前</p><p>点击右上角头像——个人账户设置——SSH公钥——新增公钥<br>复制之前<code>id_rsa.pub</code>的内容粘贴即可，公钥有效期根据需求选择，默认三个月，永久也可。</p><p>完成后在 bash 命令行测试，</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@e.coding.net</span><br></pre></td></tr></tbody></table></figure><p>出现如下反馈表示配置完成：</p><div style="width:75%;margin:auto"><img src="/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-11.PNG" class=""></div><h4 id="将-Hexo-部署到-Coding"><a href="#将-Hexo-部署到-Coding" class="headerlink" title="将 Hexo 部署到 Coding"></a>将 <strong>Hexo</strong> 部署到 <strong>Coding</strong></h4><p>代码仓库设置——基本设置——复制 <strong>SSH</strong> 地址 （如下图，图中的 test 应该默认是你的仓库名）</p><div style="width:80%;margin:auto"><img src="/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-12.PNG" class=""></div><p>打开博客根目录下的配置文件<code>_config.yml</code>，在最下面的仓库地址处添加你的 Coding 仓库的 SSH 地址。比如我的就是：</p><div style="width:80%;margin:auto"><img src="/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-13.PNG" class=""></div><p>同样步骤：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>点击仓库，注意是 <strong>master</strong> 分支，就能看到最新上传的代码文件了。</p><h4 id="网站托管"><a href="#网站托管" class="headerlink" title="网站托管"></a>网站托管</h4><p>持续部署——网站托管</p><div style="width:80%;margin:auto"><img src="/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-14.PNG" class=""></div><p>依次按照提示来即可：配置腾讯云权限——实名认证——新建网站</p><div style="width:80%;margin:auto"><img src="/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-15.PNG" class=""></div><p>网站名称添用户名即可，选择静态网站、现有仓库、网站类型：静态网站、节点：香港。如果部署区域选择的是非香港地区（北上广），配置自定义域名时需要自行备案，如不备案，则会部署失败。</p><div style="width:80%;margin:auto"><img src="/2021/07/22/Hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/image-16.PNG" class=""></div><p>点击确定之后，稍等一会，就会出现部署成功的字样，通过它自动生成的网址就可以访问你的博客啦。</p><p>另外，如果自己有绑定域名的话，可以在网站托管界面，进入网站详情页，点击自定义域名，新建域名即可。</p><h3 id="2-网站-SEO-优化"><a href="#2-网站-SEO-优化" class="headerlink" title="2. 网站 SEO 优化"></a>2. 网站 <strong>SEO</strong> 优化</h3><p>~</p><h3 id="3-优化网站加载速度"><a href="#3-优化网站加载速度" class="headerlink" title="3. 优化网站加载速度"></a>3. 优化网站加载速度</h3><p>~</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢以下文章的博主：</p><p><a href="https://shw2018.github.io/posts/6e8839eb.html">https://shw2018.github.io/posts/6e8839eb.html</a> —— <a href="https://shw2018.github.io/">https://shw2018.github.io/</a><br><a href="https://blog.csdn.net/qq_36667170/article/details/105789610#comments_15060297">https://blog.csdn.net/qq_36667170/article/details/105789610#comments_15060297</a> —— <a href="https://lolitasian.github.io/">https://lolitasian.github.io/</a><br><a href="https://zhuanlan.zhihu.com/p/157358602">https://zhuanlan.zhihu.com/p/157358602</a> —— <a href="https://zhangypcn.github.io/">https://zhangypcn.github.io/</a><br><a href="https://www.antmoe.com/posts/75a6347a/">https://www.antmoe.com/posts/75a6347a/</a><br><a href="https://www.zhihu.com/people/hu-tao-bu-ding">https://www.zhihu.com/people/hu-tao-bu-ding</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My first article</title>
      <link href="/2021/07/17/my-first-article/"/>
      <url>/2021/07/17/my-first-article/</url>
      
        <content type="html"><![CDATA[<p>This is my first time blogging with hexo.</p>]]></content>
      
      
      <categories>
          
          <category> Mileposts </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
